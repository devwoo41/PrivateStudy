## Docker 그리고 Container

#### Cloud Native Application
- cloud native application의 기본 요건 중 하나는 application을 컨테이너로 만드는 것이고, 요즘 application은 aws, azure등의 cloud를 이용해 배포. docker를 활용하면 일관된 환경을 구축할 수 있어 개발을 할때 용이하다.

#### Hello Docker
- docker는 하나의 프로그램이 아닌 여러개의 프로그램으로 이루어짐. docker desktop은 필요한 프로그램을 한번에 설치할 수 있도록 도와주고 gui도 제공한다. 실무환경에서는 GUI 보다는 CLI를 많이 사용한다. CLI에 익숙해지면 GUI보다 더 빨리 많이 쉽게 처리가 가능하다. 

#### 컨테이너와 이미지
- 컨테이너는 application을 실행하기 위한 격리된 경량 프로세스이다. 프로세스란 실행중인 프로그램을 의미한다. 예를 들어, A와B라는 두개의 프로그램을 동시에 실행한다고 하면 각각이 하나의 프로세스가 된다. 프로세스는 메모리, 파일시스템, 네트워크 등의 자원을 사용하고, 이때 프로세스는 서로가 서로에게 간섭하지 못하도록 메모리 수준으로 격리되지만 컨테이너는 파일시스템과 네트워크까지 서로 간섭하지 못하도록 격리시킨다. 격리가 필요한 이유는, 보통 애플리케이션을 실행할때 애플리케이션은 각각이 하나의 컴퓨터에서 실행되지 않는다. 하나의 컴퓨터에서 실행하는 애플리케이션도 격리된 환경이 필요하다. 그래야 서로의 간섭을 줄이고 특정 애플리케이션의 장애가 다른 애플리케이션에게 영향을 주지 않기 때문이다. 컴퓨터의 자원은 요구수준에 따라 격리수준을 달리한다. 호스트, 즉 컴퓨터 자원의 주인 (컴퓨터 그 자체)의 자원중 어떤 계층에서 격리하느냐에 따라 격리수준이 달라진다. 더 낮은 계층에서 격리할 수록 온전한 컴퓨터로 취급이 된다. 
```
메모리
--------
파일시스템 / 네트워크 / 라이브러리
--------
운영체제
```
#### 격리수준
- 운영체제 수준에서 격리하는 기술을 하이퍼바이저라고 한다. 하이퍼바이저 단위로 격리된 것(단위)을 vm(가상머신)이라고 부른다. 가상머신은 높은 수준의 격리를 제공해서 보안상 이점이 있으나, 실행 단위가 무거워지고 초기실행이 무겁다. 다음으로, 운영체제는 격리에서 제외하고 파일시스템, 네트워크, 라이브러리, 메모리 등을 격리해서 제공하는 것을 컨테이너라고 한다. 컨테이너 기술로 격리된 자원의 단위를 컨테이너라 하고, 운영체제를 포함하지 않아 vm보다 훨씬 가볍다. 현대 어플리케이션은 다양한 기능을 제공하면서 트래픽에 대응하면서 빠르게 구동해야 하므로 컨테이너가 유용하다. 그런데 컨테이너를 다른 호스트에서 동일하게 실행해야 한다. 이때, 이미지를 통해 다른 호스트들에도 동일한 컨테이너를 실행할 수 있도록 제공할 수 있다. 이미지는 컨테이너를 생성하기 위한 모든 것을 포함한 파일 묶음이다. 소스코드나 어떤 명령어나 실행방법에 대한 모든 것을 포함한다. 이렇듯 이미지는 파일 묶음이기 때문에 쉽게 전달할 수 있다. 이미지는 버전관리 체계를 가진다. 버전별로 태그를 설정할 수 있다. 이미지의 크기가 너무 커지면 네트워크를 통해 주고 받을때 효율이 떨어져서 레이어라는 방식을 통해 나누어서 저장할 수 있어, 중복 저장을 방지 할 수 있다.

#### 이미지 관리
- 이미지는 컨테이너를 실행하기 위한 모든 정보를 포함한다. 그 중에 가장 기본적으로 애플리케이션 실행환경이 필요하다. nextjs라면 node환경이 django라면 python환경이 필요한 등 말이다. 이미지는 대부분 dockerhub를 통해서 사용할 수 있다.
docker pull image [application] 뒤의 @를 통해 다이제스트를 붙이면 특정 이미지를 받아올 수 있고, 또는 뒤에 특정 버전을 붙이면 특정 버전을 받아올 수 있다. docker image prune을 통해 태그가 없는 사용하지 않는 이미지들을 삭제할 수 있다. 그러나 이런 태그가 없는 이미지 뿐만 아니라 모든 이미지를 삭제하고 싶다면 docker image prune -a를 통해 모든 이미지를 삭제하고 싶다.

#### dockerfile 작성
- 이미지는 여러개의 레이어로 구성되어있다. 그래서 이미지를 만드는 것은 여러개의 레이어를 쌓아올리는 과정과 같다. dockerfile은 레이어를 어떻게 쌓아올릴것인지에 대해 계획을 작성하는 파일이다. 정해진 문법에 따라 dockerfile을 작성하면 docker엔진이 순서대로 쌓아 파일을 만든다. 

###### node를 설치한다. (애플리케이션을 실행하는데 필요한 환경을 준비, 가장 밑에 깔리는 layer 준비), ARG 커맨드를 통해 버전을 정의해주면 도커파일 내에서 일일이 수정해줄 필요 없다.

###### 소스코드를 다운로드한다.

###### 소스코드의 최상위 디렉토리로 이동한다.

###### 소스코드를 실행할 때 필요한 파일을 다운로드한다. (npm ci)

###### 소스코드를 빌드한다. (npm run build)

###### 환경변수를 정의한다. (PORT)

###### 서버를 실행한다. (npm run start)

#### node.js를 기준으로 작성된 dockerfile
```
# node를 설치한다. (애플리케이션을 실행하는데 필요한 환경을 준비, 가장 밑에 깔리는 layer 준비)
#FROM 베이스 이미지
ARG NODE_VERSION
FROM node:${NODE_VERSION}


# 소스코드를 다운로드한다.
# COPY [복사할 경로] [붙여넣기할 경로]
COPY . /app 
# 현재 디렉토리의 내용을 app 디렉토리로 복사한다.
# 상대경로의 기준이 build context(도커파일이 있는 위치)이다.


# 소스코드의 최상위 디렉토리로 이동한다.
WORKDIR /app

# 소스코드를 실행할 때 필요한 파일을 다운로드한다. (npm ci)
RUN npm ci

# 소스코드를 빌드한다. (npm run build)
RUN npm run build

# RUN npm ci && npm run build 라는 하나의 명령어로 작성할 경우
# 레이어가 줄어들어 훨씬 좋다.

# 환경변수를 정의한다. (PORT)
ENV PORT==3000

# 서버를 실행한다. (npm run start)
ENTRYPOINT ["npm", "run", "start"]
# ENTRYPOINT를 정의할때는 조금 특이한 형태로 정의한다.
```

