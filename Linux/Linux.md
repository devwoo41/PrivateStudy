## Linux

#### CLI(Command Line Interface)
- 커맨드를 통해 컴퓨터를 사용하는 방식 (터미널)
- ex. 필요한 라이브러리를 다운받고 설치, 협업시 코드관리, 웹개발 환경 설정과 서버 실행

#### 유닉스(Unix) 커맨드
- 1970년대에 개발된 운영체제
- 소프트웨어를 개발하고 실행할 수 있는 편리한 플랫폼
- 쉽게 수정해서 다른 컴퓨터에 적용할 수 있었음
- 유닉스를 기반으로 하는 다양한 운영체제
- Macos,unix,Linux 모두 유닉스로부터 파생된 운영체제
- 웹사이트를 배포하거나 인공지능을 개발할 때 서버 컴퓨터를 사용해야 해서 유닉스 커맨드가 필요하다.

#### A@B ~ $(%)
- A@B: A라는 사용자가 B라는 컴퓨터(디바이스)에 로그인 되어 있다.
- ~: 현재 위치해 있는 폴더 (사용자의 홈 폴더)
- $(%): 프롬프트의 끝을 알리는 기호

#### shell, bash, zsh
- shell은 커맨드를 해석해주는 프로그램
- cmd창에 date나 cal같은 단어를 이해하면 shell이 컴퓨터를 이해할 수 있는 형태로 바꿔주고, 컴퓨터가 실제로 커맨드를 실행하고 결과를 되돌려줌.
- shell 종류 중 하나가 바로 bash인데, 가장 보편적이고 많은 유닉스 운영 체제에서 기본 shell로 사용. ubuntu의 기본 shell. 10.15 버전 이후부터는 zsh를 기본으로 사용. 

### 중간핵심정리
###### 명령어(ex. cal, date) -> 해석 -> shell(ex. bash,zsh) -> Linux kernel -> 하드웨어 제어

#### argument(인자), option
- ex. $cal 10 2020 라는 명령어가 있다면 10, 2020이 argument임.
- cal은 기본적으로 달력을 보여주는 명령어이고 10, 2020이라는 argument(인자)를 줌으로써 2020년 10월 자의 달력을 보여줌.
- '-'를 통해서 옵션을 줄 수 있음. 
- ex. cal -j 10 2020 라는 명령어를 주는 경우, 2020년 10월의 달력을 보여주는데 1월 1일을 기준으로 각 날이 며칠씩 지났는지 보여줌.

#### 커맨드 매뉴얼 (man)
- man이라는 명령어 뒤에 argument로 특정 명령어를 붙이면 특정 명령어에 대한 매뉴얼(manual)을 확인해 볼 수 있음. F(forward) 키를 통해 페이지 단위로 내려 볼 수 있고, B(backward) 명령어를 통해 페이지 단위로 올려 볼 수 있음. 
- 매뉴얼의 name 섹션에는 명령어와 명령어가 어떤거를 할 수 있는지 알려줌. synopsis 섹션에는 명령어의 argument 형태와 여러 옵션들이 나타나 있음. description이라는 섹션에서는 cal 커맨드에 대한 일반적인 설명이 있고, 아래에는 여러 옵션에 대한 설명도 적혀 있음. A옵션은 현재 달 이전 number개의 달을 출력해주고 B옵션은 현재 달 이후 number개의 달을 출력해줌. 각 옵션의 아래에는 유의사항이 적혀있고, 비슷한 커맨드들과 참고정보가 나와있음.

###### 커맨드를 입력하는 도중 tab키를 누르면 관련된 커맨드가 자동완성되어 입력됨. cd로 경로를 탐색하여 타이핑할때 tab키를 누르면 하위의 디렉토리나 파일 중 관련된 이름이 자동완성되어 입력됨.

#### 유닉스 디렉토리(폴더 구조)와 파일경로
- 유닉스 디렉토리 구조는 거꾸로 된 나무와 같다. 최상위에는 루트 또는 최상위 디렉토리가 있고, 그 아래에는 여러 디렉토리가 있고, 그 하위에는 또 여러 디렉토리가 있는 가지로 뻗어나가는 방식이다. 여기서 중요한 디렉토리는 사용자의 홈 디렉토리이다. 사용자의 홈 디렉토리 안에는 각종 문서,  바탕화면 파일, 다운로드 파일 등이 있다. 사용자의 개인 파일들은 사용자의 홈 디렉토리 안에 있고, 컴퓨터에 일반적으로 필요한 파일들은 홈 디렉토리 바깥에 있다. 
- 파일 경로를 통해 디렉토리나 폴더의 위치를 문자열로 표기할 줄 알아야 한다. 루트 디렉토리로 부터 경로를 작성하는 경우 앞에 아무것도 붙이지 않고 '/'를 붙이면 자동으로 루트 디렉토리로부터 경로가 작성된다. 즉 '/usr/bin'이라 하면 사실 'root/usr/bin' 이라는 의미이다. 현재 로그인된 사용자의 홈 디렉토리는 '~' 표로 사용할 수 있다. 즉, 예로써 taeho라는 user로 현재 로그인이 되어있다면, '~'의 의미는 /home/taeho 라는 경로를 나타낸다.
- 즉, /home/taeho/documents의 경우 ~/documents로 줄여서 사용하는 것이 가능하다.

#### pwd, cd, ls (cmd 명령어)
- 현재 위치를 확인하기 위해서는 pwd를 치면 현재경로, 즉 working directory의 위치를 확인할 수 있습니다. 
- cd를 통해 다른 디렉토리로 이동할 수 있습니다. 아규먼트로 이동할 디렉토리의 경로를 주면 됩니다. 즉, 루트 디렉토리로 이동하기 위해서는 'cd /' 만 입력해도 루트 디렉토리로 이동할 수 있습니다. 앞서 설명한 듯이 '/'만 사용해도 루트 디렉토리로 이동할 수 있습니다.  
- cd / 를 통해 루트 디렉토리로 이동한 후, 다시 cd 뒤의 argument에 아무것도 넣지 않은 채로 입력하면 자동으로 /home/user 로 이동한다. 
- 'cd -' 라는 명령어를 통해 cd를 하기 이전의 경로로 이동할 수 있다.
- ls 라는 명령어를 통해 디렉토리의 안에 뭐가 들었는지 쭉 볼수 있다. 

#### 절대경로와 상대경로
- 절대경로로 cd를 하거나 경로를 읽을 경우에 불편한 점이 있다. 예를 들어, 현재 경로가 /home/user/documents/project/django의 경우, django 아래의 django_coplate로 이동하기 위해서는 'cd /home/user/documents/project/django/django_coplate' 라는 복잡한 명령어를 사용해야 한다.
- 그러나 상대경로를 이용하면 루트를 기준으로 경로를 나타내는 것이 아닌 현재 자신이 위치한 디렉토리를 기준으로 표현한다. 현재 디렉토리를 '.'으로 표시한다. 그러면 'cd ./django_coplate'라는 간단한 명령어를 통해 현재 디렉토리(django) 아래의 django_coplate로 이동할 수 있다. 상위 디렉토리는 '.'이 아닌 '..'을 통해 표시할 수 있다. 즉 'cd ..'을 한다면 현재 경로인 'django'위의 'project'로 이동하게 되는 것이다. 

###### 파일이름이나 디렉토리 이름에 공백이 있으면 작은 따옴표를 사용해 묶어줘야 한다. 예를 들어 hello world라는 디렉토리로 이동하고 싶은 경우 " cd 'hello world' "라고 입력해야 한다.

#### ls 커맨드
- 'ls -a' 라는 커맨드를 통해 ls에 a 옵션을 줌으로써 숨겨진 파일을 포함한 모든 내용물을 볼 수 있다. 숨겨진 파일은 '.'가 앞에 붙어있다. 숨겨진 파일 중 .bash_history 는 bash 셸창에서 사용했던 커맨드를 기록하고 있다. 'ls -1'이라는 명령어를 사용하면 경로 내의 파일과 디렉토리에 관해 더 많은 정보가 나온다. 그렇다면 숨겨진 파일에 관해서 정보를 더 많이 보고 싶은 경우 어떻게 할까? -a 옵션을 통해 숨겨진 파일을 확인할 수 있고 -l(long format) 이라는 옵션을 통해 정보를 확인할 수 있다. 따라서 숨겨진 파일에 대한 정보를 확인하는 방법은 'ls -al'이다. 'ls -1'을 입력해서 뜨는 total은 파일 개수가 아니라 디렉토리의 내용물이 얼마나 많은 공간을 차지하고 있는지를 말해줌. 첫 컬럼의 첫 글자는 파일종류를 말한다. 나머지 글자는 조회, 실행 등의 권한에 대해서 나타내고 있음. 그리고 두번째 column은 이 파일과 연결된 링크의 개수를 의미한다. 세번째 column은 파일의 소유자이고, 네번째 column은 소유자가 속한 그룹이고, 다섯번째 column은 파일의 용량을 얘기해주고 있고, 디렉토리의 경우 용량을 나타내는 것이 아니라 그 다음 column은 파일의 수정 날짜이고, 마지막 column은 파일의 이름이다. 

#### bin
- bin은 binaries의 약자이다. binary는 간단히 말해서 컴퓨터가 실행할 수 있는 프로그램을 뜻합니다. sbin은 bin과 비슷한데, 관리자 전용 프로그램들이 있다.

#### usr
- usr은 사용자에게 필요한 파일들을 저장하고 있습니다. /usr 안에도 각종 binary를 저장하고 있는 bin 디렉토리가 있다. bin에는 컴퓨터가 시작하거나 자신을 수리하기 위해서 꼭 필요한 커맨드들이 있고, /usr/bin에는 컴퓨터가 필요하기보다는 사용자가 필요한 커맨드들이 있습니다. 그리고 /usr 안에는 local 이라는 디렉토리가 있는데, 여기에는 사용자가 직접 설치한 프로그램과 관련된 파일들이 있다.

#### mkdir, touch
- mkdir로 디렉토리를 만들고 touch로 디렉토리 내부의 txt 등의 파일을 생성, touch 뒤에 여러 인자(argument)를 줌으로써, 여러 파일을 생성할 수 있다.

#### CLI 텍스트 에디터 vim
- GUI 환경에서는 파일 내용을 작성하거나 수정하는 등 텍스트를 편집할 때, Microsoft Word, VS Code, PyCharm, 메모장 등이 이용되는데, CLI 환경에서는 VIM이라는 텍스트 에디터가 활용된다. 엄청나게 많은 기능과 단축키가 있고, 모든 걸 마우스 없이 키보드로 해결해야 한다. 

#### vim의 4가지 사용모드

###### 일반모드
- 커서 이동, 텍스트 붙여넣기, 작업 취소
###### 입력모드
- 텍스트 입력
###### 비주얼모드
- 텍스트 블록 지정, 텍스트 복사
###### 명령모드
- 내용 저장, vim 종료

###### 입력모드->일반모드 : i
###### 비주얼모드->일반모드 : v
###### 명령모드->일반모드 : :
###### 일반모드->입력모드,비주얼모드,명령모드 : esc
###### 파일을 저장하고 싶으면 ':w'
###### vim을 끄고 싶으면 ':q'
###### 파일을 저장하고 끄고 싶으면 ':wq'
###### 파일을 저장하지 않고 끄고 싶으면 ':q!'

```
단축키 정리
텍스트 입력: 입력 모드(i) → 텍스트 입력
텍스트 한 줄 복사: 일반 모드 → 복사하고 싶은 줄에 커서 위치 → yy
텍스트 한 줄 잘라내기: 일반 모드 → 잘라내고 싶은 줄에 커서 위치 → dd
특정 영역 복사: 비주얼 모드(V는 줄 단위, v는 글자 단위) → 복사하고 싶은 영역 커서로 설정 → y
특정 영역 잘라내기: 비주얼 모드(V는 줄 단위, v는 글자 단위) → 잘라내고 싶은 영역 커서로 설정 → d
텍스트 붙여넣기: 일반 모드 → 붙여넣고 싶은 위치에 커서 위치 → p
파일 저장: 명령 모드(:) → w + enter
파일 저장 + vim 종료: 명령 모드(:) → wq + enter
vim 종료 (내용 저장되지 않음): 명령 모드(:) → q! + enter
```

#### cat, less, head, tail 커맨드
- cat 커맨드는 txt 파일의 내용을 조회할 수 있고, less 커맨드는 파일의 내용을 페이지 단위로 조회할 수 있다. head는 파일의 시작 부분, tail은 파일의 끝 부분을 조회할 수 있는 커맨드이다.

#### cp 커맨드
- cp 커맨드를 이용해서 -i 옵션을 준다면 파일의 내용을 똑같은 이름을 가진 파일에 덮어쓸 수 있다. -r 옵션을 이용한다면 디렉토리를 복사할 때, 디렉토리를 그대로 복사해 이용할 수 있다. 

#### rm 커맨드
- rm의 경우도 똑같다 rm 뒤의 인자(argument)를 준다면 그 해당하는 파일과 디렉토리를 지울 수 있다. -i 옵션을 준다면 확실히 지울것인지를 확인 할 수 있고 -r 옵션을 준다면 디렉토리를 지울 수 있다. -f 옵션을 준다면 확인하지 않고 그냥 지워버린다. 

```
pwd (print working directory)
사용법:

pwd
예:

pwd
현재 디렉토리 (working directory)의 경로를 출력한다.

cd (change directory)
사용법:

cd [PATH]
예:

cd dir1
PATH 경로에 해당하는 디렉토리로 이동한다.

아무 아규먼트 없이 cd를 하면 사용자의 홈 디렉토리로 이동한다.

-을 사용하면 이전 경로로 돌아간다.

cd path/to/foo    (foo 디렉토리로 이동)
cd path/to/bar    (bar 디렉토리로 이동)
cd -              (다시 foo 디렉토리로 이동)
ls (list)
사용법:

ls [-al] [PATH]
예:

ls -al dir1
PATH에 해당하는 디렉토리 / 파일 정보를 보여줍니다. PATH 아규먼트를 안 주면 현재 디렉토리 정보를 보여준다.

a 옵션: 숨겨진 파일을 포함한 모든 파일을 보여준다.

l 옵션: long format을 사용해서 더 자세한 정보를 보여준다.

a, l 외에도 많은 옵션이 있습니다. man ls를 통해 확인해!

mkdir (make directory)
사용법:

mkdir PATH1 PATH2 ...
예:

mkdir dir2
디렉토리를 생성한다. 여러 경로를 한꺼번에 줘서 여러 디렉토리를 한꺼번에 만들 수도 있다.

touch (touch file)
사용법:

touch PATH1 PATH2 ...
예:

touch file1.txt
경로에 해당하는 파일을 생성한다. (원래는 파일의 마지막 접근 시간 / 수정 시간을 업데이트하는데 쓰이지만 파일이 존재하지 않으면 새로 생성하기 때문에 파일 생성 용도로도 쓰인다.)

vim
사용법:

vim [PATH]
예:

vim file1.txt
vim 텍스트 에디터를 실행합니다.

cat (concatenate)
사용법:

cat PATH1 PATH2 ...
예:

cat file1.txt
경로에 해당하는 파일들의 내용을 출력한다. 파일이 여러 개인 경우 내용을 모두 붙여서 출력한다.

less
사용법:

less PATH
예:

less file1.txt
PATH에 해당하는 파일을 페이지 단위로 나눠서 보여준다.

단축키:

줄 이동: 위쪽 / 아래쪽 방향키
다음 페이지: space 아니면 f
이전 페이지: b
마지막 페이지: G
처음 페이지: g
head
사용법:

head [-n count] PATH
예:

head -n 5 file1.txt
PATH에 해당하는 파일의 처음 10줄을 출력한다.

n 옵션: 출력되는 줄 개수를 바꾼다.

tail
사용법:

tail [-n count] PATH
예:

tail -n 5 file1.txt
PATH에 해당하는 파일의 마지막 10줄을 출력한다.

n 옵션: 출력되는 줄 개수를 바꾼다.

mv (move)
사용법:

mv [-i] SOURCE_PATH DEST_PATH
예:

mv -i file1.txt file2.txt
mv -i file1.txt dir1
디렉토리/파일을 이동하거나 이름을 변경합니다. 두 번째 아규먼트(DEST_PATH) 가 이미 존재하는 디렉토리의 경로일 경우 SOURCE_PATH에 해당하는 디렉토리/파일을 그 안으로 이동하고, 그렇지 않으면 DEST_PATH로 이름 변경한다.

i 옵션: 이동/이름 변경을 할 때 똑같은 이름의 디렉토리/파일이 있으면 덮어씌워진다. 확인을 하면서 mv를 하려면 i 옵션을 사용하면 된다.

cp (copy)
사용법:

cp [-ri] SOURCE_PATH DEST_PATH
예:

cp -i file1.txt file2.txt
cp -ri dir1 dir2
디렉토리/파일을 복사한다. 두 번째 아규먼트(DEST_PATH) 가 이미 존재하는 디렉토리의 경로일 경우 SOURCE_PATH에 해당하는 디렉토리/파일을 그 안으로 복사하고, 그렇지 않으면 DEST_PATH라는 이름으로 복사한다.

r 옵션: 디렉토리를 복사할 때는 꼭 r 옵션을 써야 한다.

i 옵션: 복사할 때 똑같은 이름의 파일이 있으면 덮어씌워진다. 확인을 하면서 cp를 하려면 i 옵션을 사용하면 된다.

rm (remove)
사용법:

rm [-rif] PATH1 PATH2 ...
예:

rm file1.txt file2.txt
rm -rf dir1
경로에 해당하는 파일/디렉토리들을 지워준다.

r 옵션: 디렉토리를 삭제할 때는 꼭 r 옵션을 써야 한다.

i 옵션: 삭제할 때 각 파일을 정말 지울 것인지 물어본다.

f 옵션: 지울 것인지 절대 확인하지 않고 바로 지운다.
```

#### apt 커맨드
- apt 커맨드를 이용해서 sudo 권한을 가지고 외부 패키지나 애플리케이션, 파일 등을 설치하거나 지우거나 등의 권한부여적인 조작을 많이 할 수 있다. 'sudo apt update'라는 커맨드를 이용해서 패키지나 기존의 환경을 최신상황으로 업데이트 해주고 항상 apt 커맨드를 이용해 조작을 해주어야 한다. 'sudo apt install mc'라는 커맨드를 이용해서 mc라는 패키지를 설치한다면 tui를 만들어서 텍스트 기반으로 interface를 조작할 수 있다.

#### WSL로 윈도우에 있는 파일 접근하기
```
WSL을 사용하면 듀얼 부팅이나 가상 머신을 사용하는 것보다 더 가볍게 리눅스 환경을 이용할 수 있다. 사실 WSL을 사용하는 데에는 또 다른 장점이 있는데, 바로 윈도우에 있는 파일에 쉽게 접근할 수 있다는 거다. 듀얼 부팅이나 가상 머신을 사용하면 별도의 리눅스 환경이 생성되기 때문에 리눅스를 사용할 때는 윈도우에 있는 파일에 접근하기 어려운데, WSL은 윈도우 안에 존재하는 '하위 시스템'이기 때문에 윈도우 파일에 쉽게 접근할 수 있다. 어떻게 접근하는지 바로 알아보자

윈도우 파일은 /mnt/c 경로에 있고, /mnt/c 가 윈도우의 C: 드라이브이기 때문이다. 사용자의 홈 디렉토리는 C: 드라이브의 Users 디렉토리 안에 있는데, Users 뒤에 윈도우 사용자 이름을 붙이면 된다. 그러니까 사용자 이름이 username이라면 username 사용자의 홈 디렉토리는 /mnt/c/Users/username이 되는 거다.
```

###### powrshell과 cmd 많은 사용자들이(특히 초보들이... 나 포함임...) powershell에 대해서 초반에 궁금해 하는 사람들이 많이 있다.  






######                                                                              REF. Codeit + LWJ source